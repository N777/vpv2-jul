//**************************************************************************************
// Пример исследования реализации функции sin(x)/x = 1 - x^2/3! + x^4/5! - x^6/7! + ...
// vpv-lab2: март 2020:: nvnulstu@gmail.com 
//**************************************************************************************
#pragma once
#include "stdlib.h"
#include <string>
#include <algorithm>
#include <vector>
#include "bern.h"

using namespace std;

#define LEN_RES 19  // разрядность результата функции, в младшем бите которого может быть ошибка
#define MAX_ERR (float)(1.0/(1 << LEN_RES)) // максимум погрешности равен 2^(-LEN_RES)
#define LEN_POLINOM 13 // достаточно иметь 5 членов ряда
#define X_STEP ((float)1.0/(float)(1 << 24)) // 2^(-24) - вес младшего разряда мантиссы float

// Значения факториалов 
#define FACT3 (float)(2 * 3)
#define FACT5 (float)(2 * 3 * 4 * 5)
#define FACT7 (float)(2 * 3 * 4 * 5 * 6 * 7)
#define FACT9 (float)(2 * 3 * 4 * 5 * 6 * 7 * 8 * 9)

// Значение обратных величин факториалов (float)
#define DIV1_FACT3 (1./FACT3)
#define DIV1_FACT5 (1./FACT5)
#define DIV1_FACT7 (1./FACT7)
#define DIV1_FACT9 (1./FACT9)


// Моя залупа
#define DOUBLE_FACT1 (float)(2 * 1)
#define DOUBLE_FACT2 (float)(2 * 1 * 2)
#define DOUBLE_FACT3 (float)(2 * 1 * 2 * 3)
#define DOUBLE_FACT4 (float)(2 * 1 * 2 * 3 * 4)
#define DOUBLE_FACT5 (float)(2 * 1 * 2 * 3 * 4 * 5)
#define DOUBLE_FACT6 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6)
#define DOUBLE_FACT7 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7)
#define DOUBLE_FACT8 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8)
#define DOUBLE_FACT9 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9)
#define DOUBLE_FACT10 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10)
#define DOUBLE_FACT11 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11)
#define DOUBLE_FACT12 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12)
#define DOUBLE_FACT13 (float)(2 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13)

#define BERN1 (float)(1 / 6)
#define BERN2 (float)(1 / 30)
#define BERN3 (float)(1 / 42)
#define BERN4 (float)(1 / 30)
#define BERN5 (float)(5 / 66)
#define BERN6 (float)(691 / 2730)
#define BERN7 (float)(7 / 6)
#define BERN8 (float)(3617 / 510)
#define BERN9 (float)(43867 / 798)
#define BERN10 (float)(174611 / 330)
#define BERN11 (float)(854513 / 138)
#define BERN12 (float)(236364091 / 2730)
#define BERN13 (float)(8553103 / 6)

typedef float(*FloatFunc)(float); // Указатель на функцию вещественных переменн

typedef long FixPoint;

// В дробной части фиксированного числа 30 бит
#define FRACT_PART 30 
// 2^31 - множитель для получения 31 бита мантиссы в long, имитирующем число с фиксированной точкой  
#define FACTOR (1 << FRACT_PART) 
#define FLOAT2FIX(x) (FixPoint)(x * FACTOR) // преобразование float в Fixed
#define FIX2FLOAT(x) ((float)x / FACTOR)   // преобразование Fixed во float
#define FIXMUL(x,y) ((FixPoint)((__int64)x * (__int64)y >> FRACT_PART))     // умножение фиксированных в С++ требует двойной точности
// Значение обратных величин факториалов (FixPointt)
#define DIV1_FACT1FP (FixPoint)FLOAT2FIX(1.0) // 1 в формате FixPoint
#define DIV1_FACT3FP (FixPoint)FLOAT2FIX(DIV1_FACT3)
#define DIV1_FACT5FP (FixPoint)FLOAT2FIX(DIV1_FACT5)
#define DIV1_FACT7FP (FixPoint)FLOAT2FIX(DIV1_FACT7)
#define DIV1_FACT9FP (FixPoint)FLOAT2FIX(DIV1_FACT9)
#define TAB "\t"

// Измерение времени в тактах по схеме "барьер - чтение TSC"
#define CPUID_RDTSC(t) \
	__asm xor eax, eax\
	__asm cpuid __asm rdtsc\
	__asm mov DWORD PTR[t], eax\
	__asm mov DWORD PTR[t + 4], edx

typedef FixPoint(*FixedFunc)(FixPoint); // Указатель на функцию вещественных переменных

vector<float> arrX; // массив аргументов для серий измерений

float flMathFunc(float);
// Результат серии измерений с поддержкой сравнительного анализа
struct Result {
	string shortname;	// короткое имя релиза вместо номера
	string name;		// Наименование релиза функции
	__int64 min, max;	// минимум и максимум числа тактов затрат времени (до фильтрации)
	double avg, dev;	// среднее и СКО
	double factor;		// отношение avg данного метода к avg самого быстрого метода
	Result(string sn, string nm, __int64 minim, __int64 maxim, double average, double deviation) :
		shortname(sn), name(nm), min(minim), max(maxim), avg(average), dev(deviation) {};
};

class Report; // отчет

struct Config {
	int count;			// Число замеров в одной серии
	int delMax, delMin;	// Число удаляемых максимальных и минимальных элементов при фильтрации результатов серии измерений
	int lenPrintLog;	// Число первых результатов серии измерений, выводимых на консоль
	int pass;			// число проходов для анализа повторяемости
	Report * rep;		// указатель на отчет
	float maxErr;		// максимально допустимая погрешность
	float xStepVerify;	// шаг обхода значений аргумента при верификации float
	__int64 overhead;	// оценка накладных расходов на измерение времени в тактах
	Config(int cnt, int maxd, int mind, int nPrint, int npass, Report * report, float err, float step, __int64 over)
		  :	count(cnt), delMax(maxd), delMin(mind), lenPrintLog(nPrint), pass(npass), rep(report), maxErr(err), 
			xStepVerify(step), overhead(over) {};
};